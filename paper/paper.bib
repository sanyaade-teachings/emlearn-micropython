
@misc{micropython,
  author = {George, Damien P and contributors},
  title = {MicroPython - Python for Microcontrollers},
  year = {2014},
  publisher = {GitHub},
  journal = {GitHub repository},
  howpublished = {\url{https://github.com/micropython/micropython}}
}

@ARTICLE{scipy,
  author  = {Virtanen, Pauli and Gommers, Ralf and Oliphant, Travis E. and
            Haberland, Matt and Reddy, Tyler and Cournapeau, David and
            Burovski, Evgeni and Peterson, Pearu and Weckesser, Warren and
            Bright, Jonathan and {van der Walt}, St{\'e}fan J. and
            Brett, Matthew and Wilson, Joshua and Millman, K. Jarrod and
            Mayorov, Nikolay and Nelson, Andrew R. J. and Jones, Eric and
            Kern, Robert and Larson, Eric and Carey, C J and
            Polat, {\.I}lhan and Feng, Yu and Moore, Eric W. and
            {VanderPlas}, Jake and Laxalde, Denis and Perktold, Josef and
            Cimrman, Robert and Henriksen, Ian and Quintero, E. A. and
            Harris, Charles R. and Archibald, Anne M. and
            Ribeiro, Ant{\^o}nio H. and Pedregosa, Fabian and
            {van Mulbregt}, Paul and {SciPy 1.0 Contributors}},
  title   = {{{SciPy} 1.0: Fundamental Algorithms for Scientific
            Computing in Python}},
  journal = {Nature Methods},
  year    = {2020},
  volume  = {17},
  pages   = {261--272},
  adsurl  = {https://rdcu.be/b08Wh},
  doi     = {10.1038/s41592-019-0686-2},
}

@article{scikit-learn,
  title={Scikit-learn: Machine Learning in {P}ython},
  author={Pedregosa, F. and Varoquaux, G. and Gramfort, A. and Michel, V.
          and Thirion, B. and Grisel, O. and Blondel, M. and Prettenhofer, P.
          and Weiss, R. and Dubourg, V. and Vanderplas, J. and Passos, A. and
          Cournapeau, D. and Brucher, M. and Perrot, M. and Duchesnay, E.},
  journal={Journal of Machine Learning Research},
  volume={12},
  pages={2825--2830},
  year={2011}
}

@misc{keras,
  title={Keras},
  author={Chollet, Fran\c{c}ois and others},
  year={2015},
  howpublished={\url{https://keras.io}},
} 

@misc{tensorflow,
title={ {TensorFlow}: Large-Scale Machine Learning on Heterogeneous Systems},
url={https://www.tensorflow.org/},
note={Software available from tensorflow.org},
author={
    Mart\'{i}n~Abadi and
    Ashish~Agarwal and
    Paul~Barham and
    Eugene~Brevdo and
    Zhifeng~Chen and
    Craig~Citro and
    Greg~S.~Corrado and
    Andy~Davis and
    Jeffrey~Dean and
    Matthieu~Devin and
    Sanjay~Ghemawat and
    Ian~Goodfellow and
    Andrew~Harp and
    Geoffrey~Irving and
    Michael~Isard and
    Yangqing Jia and
    Rafal~Jozefowicz and
    Lukasz~Kaiser and
    Manjunath~Kudlur and
    Josh~Levenberg and
    Dandelion~Man\'{e} and
    Rajat~Monga and
    Sherry~Moore and
    Derek~Murray and
    Chris~Olah and
    Mike~Schuster and
    Jonathon~Shlens and
    Benoit~Steiner and
    Ilya~Sutskever and
    Kunal~Talwar and
    Paul~Tucker and
    Vincent~Vanhoucke and
    Vijay~Vasudevan and
    Fernanda~Vi\'{e}gas and
    Oriol~Vinyals and
    Pete~Warden and
    Martin~Wattenberg and
    Martin~Wicke and
    Yuan~Yu and
    Xiaoqiang~Zheng},
  year={2015},
}

@article{OpenMV,
  author       = {Ibrahim Abdelkader and
                  Yasser El{-}Sonbaty and
                  Mohamed El{-}Habrouk},
  title        = {Openmv: {A} Python powered, extensible machine vision camera},
  journal      = {CoRR},
  volume       = {abs/1711.10464},
  year         = {2017},
  url          = {http://arxiv.org/abs/1711.10464},
  eprinttype    = {arXiv},
  eprint       = {1711.10464},
  timestamp    = {Mon, 13 Aug 2018 16:47:34 +0200},
  biburl       = {https://dblp.org/rec/journals/corr/abs-1711-10464.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@article{karavaev2024tinydecisiontreeclassifier,
  title={TinyDecisionTreeClassifier: Embedded C++ library for training and applying decision trees on the edge},
  author={Karavaev, Aleksei and Hejda, Jan and Kutilek, Patrik and Volf, Petr and Sokol, Marek and Leova, Lydie},
  journal={SoftwareX},
  volume={27},
  pages={101778},
  year={2024},
  publisher={Elsevier}
}

@misc{emlearn,
  author       = {Nordby, Jon AND Cooke, Mark AND Horvath, Adam},
  title        = {{emlearn: Machine Learning inference engine for 
                   Microcontrollers and Embedded Devices}},
  month        = mar,
  year         = 2019,
  doi          = {10.5281/zenodo.2589394},
  url          = {https://doi.org/10.5281/zenodo.2589394}
}


@article{antonini_adaptable_2023,
	title = {An Adaptable and Unsupervised {TinyML} Anomaly Detection System for Extreme Industrial Environments},
	volume = {23},
	rights = {http://creativecommons.org/licenses/by/3.0/},
	issn = {1424-8220},
	url = {https://www.mdpi.com/1424-8220/23/4/2344},
	doi = {10.3390/s23042344},
	abstract = {Industrial assets often feature multiple sensing devices to keep track of their status by monitoring certain physical parameters. These readings can be analyzed with machine learning ({ML}) tools to identify potential failures through anomaly detection, allowing operators to take appropriate corrective actions. Typically, these analyses are conducted on servers located in data centers or the cloud. However, this approach increases system complexity and is susceptible to failure in cases where connectivity is unavailable. Furthermore, this communication restriction limits the approach’s applicability in extreme industrial environments where operating conditions affect communication and access to the system. This paper proposes and evaluates an end-to-end adaptable and configurable anomaly detection system that uses the Internet of Things ({IoT}), edge computing, and Tiny-{MLOps} methodologies in an extreme industrial environment such as submersible pumps. The system runs on an {IoT} sensing Kit, based on an {ESP}32 microcontroller and {MicroPython} firmware, located near the data source. The processing pipeline on the sensing device collects data, trains an anomaly detection model, and alerts an external gateway in the event of an anomaly. The anomaly detection model uses the isolation forest algorithm, which can be trained on the microcontroller in just 1.2 to 6.4 s and detect an anomaly in less than 16 milliseconds with an ensemble of 50 trees and 80 {KB} of {RAM}. Additionally, the system employs blockchain technology to provide a transparent and irrefutable repository of anomalies.},
	pages = {2344},
	number = {4},
	journaltitle = {Sensors},
	author = {Antonini, Mattia and Pincheira, Miguel and Vecchio, Massimo and Antonelli, Fabio},
	urldate = {2025-01-19},
	date = {2023-01},
	langid = {english},
	note = {Number: 4
Publisher: Multidisciplinary Digital Publishing Institute},
	keywords = {anomaly detection, blockchain, Internet of Things, machine learning, Tiny-{MLOps}, {TinyML}},
	file = {Full Text PDF:/home/jon/Zotero/storage/S35SMC2T/Antonini et al. - 2023 - An Adaptable and Unsupervised TinyML Anomaly Detec.pdf:application/pdf},
}

@inproceedings{kokoulin_hierarchical_2019,
	title = {Hierarchical Convolutional Neural Network Architecture in Distributed Facial Recognition System},
	url = {https://ieeexplore.ieee.org/abstract/document/8656727},
	doi = {10.1109/EIConRus.2019.8656727},
	abstract = {Authors propose an efficient distributed facial recognition system based on the cascade of Convolutional Neural Networks. The traditional approach utilizing the centralized schema of recognition system has its main disadvantage concluding a high traffic and computing load of the central processing server: the more video surveillance cameras are served by the central unit, the more its load rate. But most of the time the high-quality video stream does not consist of facial information and the computational resources are being wasted. The main principle of our recognition system is the distributed hierarchical processing network utilizing the "coarse-fine" paradigm. Each source video stream is processed in-place by the tiny {SoC} computer which acts as an Edge Computing Unit and detects the presence of a face fragment in a video frame and crops the bounds of the {ROI}. The resulting stream including {ROI} is relayed to the main server if the face is detected.},
	eventtitle = {2019 {IEEE} Conference of Russian Young Researchers in Electrical and Electronic Engineering ({EIConRus})},
	pages = {258--262},
	booktitle = {2019 {IEEE} Conference of Russian Young Researchers in Electrical and Electronic Engineering ({EIConRus})},
	author = {Kokoulin, Andrey N. and Tur, Aleksandr I. and Yuzhakov, Aleksandr A. and Knyazev, Aleksandr I.},
	urldate = {2025-01-19},
	date = {2019-01},
	note = {{ISSN}: 2376-6565},
	keywords = {Cameras, Convolutional Neural Network, Detectors, Distributed System, Face, Face recognition, Facial Recognition, Histograms, Servers, Streaming media},
	file = {IEEE Xplore Abstract Record:/home/jon/Zotero/storage/4H2BUBB4/8656727.html:text/html},
}

@article{akam_open-source_2022,
	title = {Open-source, Python-based, hardware and software for controlling behavioural neuroscience experiments},
	volume = {11},
	issn = {2050-084X},
	url = {https://doi.org/10.7554/eLife.67846},
	doi = {10.7554/eLife.67846},
	abstract = {Laboratory behavioural tasks are an essential research tool. As questions asked of behaviour and brain activity become more sophisticated, the ability to specify and run richly structured tasks becomes more important. An increasing focus on reproducibility also necessitates accurate communication of task logic to other researchers. To these ends, we developed {pyControl}, a system of open-source hardware and software for controlling behavioural experiments comprising a simple yet flexible Python-based syntax for specifying tasks as extended state machines, hardware modules for building behavioural setups, and a graphical user interface designed for efficiently running high-throughput experiments on many setups in parallel, all with extensive online documentation. These tools make it quicker, easier, and cheaper to implement rich behavioural tasks at scale. As important, {pyControl} facilitates communication and reproducibility of behavioural experiments through a highly readable task definition syntax and self-documenting features. Here, we outline the system’s design and rationale, present validation experiments characterising system performance, and demonstrate example applications in freely moving and head-fixed mouse behaviour.},
	pages = {e67846},
	journaltitle = {{eLife}},
	author = {Akam, Thomas and Lustig, Andy and Rowland, James M and Kapanaiah, Sampath {KT} and Esteve-Agraz, Joan and Panniello, Mariangela and Márquez, Cristina and Kohl, Michael M and Kätzel, Dennis and Costa, Rui M and Walton, Mark E},
	editor = {Kemere, Caleb and Wassum, Kate M and Kemere, Caleb and Siegle, Josh},
	urldate = {2025-01-19},
	date = {2022-01-19},
	note = {Publisher: {eLife} Sciences Publications, Ltd},
	keywords = {Behaviour, Hardware, open source, Software},
	file = {Full Text PDF:/home/jon/Zotero/storage/PPXPRQ5L/Akam et al. - 2022 - Open-source, Python-based, hardware and software f.pdf:application/pdf},
}

@article{bordin_yamashita_coffee_2023,
	title = {Coffee disease classification at the edge using deep learning},
	volume = {4},
	issn = {2772-3755},
	url = {https://www.sciencedirect.com/science/article/pii/S2772375523000138},
	doi = {10.1016/j.atech.2023.100183},
	abstract = {Brazil is the world’s largest producer and exporter of coffee and the second largest consumer of the beverage. The aim of this study is to embed convolutional networks in a low-cost microcontrolled board to classify coffee leaf diseases in loco, without the need for an internet connection. Early identification of diseases in coffee plantations is crucial for productivity and production quality. Two datasets were used, in addition to images taken with the development board itself, totaling more than 6000 images of six different types of diseases. The proposed architectures (cascade and single-stage), when embedded, presented accuracy values around 98\% and 96\%, respectively, demonstrating their ability to assist in the diagnosis of diseases in coffee farms, especially those managed by producers with less resources.},
	pages = {100183},
	journaltitle = {Smart Agricultural Technology},
	shortjournal = {Smart Agricultural Technology},
	author = {Bordin Yamashita, João Vitor Yukio and Leite, João Paulo R. R.},
	urldate = {2025-01-19},
	date = {2023-08-01},
	keywords = {Artificial intelligence, Coffee diseases, Convolutional networks, Deep learning, Edge computing},
	file = {ScienceDirect Snapshot:/home/jon/Zotero/storage/787EE7L4/S2772375523000138.html:text/html},
}

@article{plauska_performance_2023,
	title = {Performance Evaluation of C/C++, {MicroPython}, Rust and {TinyGo} Programming Languages on {ESP}32 Microcontroller},
	volume = {12},
	rights = {http://creativecommons.org/licenses/by/3.0/},
	issn = {2079-9292},
	url = {https://www.mdpi.com/2079-9292/12/1/143},
	doi = {10.3390/electronics12010143},
	abstract = {The rapid growth of the Internet of Things ({IoT}) and its applications requires high computational efficiency, low-cost, and low-power solutions for various {IoT} devices. These include a wide range of microcontrollers that are used to collect, process, and transmit {IoT} data. {ESP}32 is a microcontroller with built-in wireless connectivity, suitable for various {IoT} applications. The {ESP}32 chip is gaining more popularity, both in academia and in the developer community, supported by a number of software libraries and programming languages. While low- and middle-level languages, such as C/C++ and Rust, are believed to be the most efficient, {TinyGo} and {MicroPython} are more developer-friendly low-complexity languages, suitable for beginners and allowing more rapid coding. This paper evaluates the efficiency of the available {ESP}32 programming languages, namely C/C++, {MicroPython}, Rust, and {TinyGo}, by comparing their execution performance. Several popular data and signal processing algorithms were implemented in these languages, and their execution times were compared: Fast Fourier Transform ({FFT}), Cyclic Redundancy Check ({CRC}), Secure Hash Algorithm ({SHA}), Infinite Impulse Response ({IIR}), and Finite Impulse Response ({FIR}) filters. The results show that the C/C++ implementations were fastest in most cases, closely followed by {TinyGo} and Rust, while {MicroPython} programs were many times slower than implementations in other programming languages. Therefore, the C/C++, {TinyGo}, and Rust languages are more suitable when execution and response time are the key factors, while Python can be used for less strict system requirements, enabling a faster and less complicated development process.},
	pages = {143},
	number = {1},
	journaltitle = {Electronics},
	author = {Plauska, Ignas and Liutkevičius, Agnius and Janavičiūtė, Audronė},
	urldate = {2025-01-19},
	date = {2023-01},
	langid = {english},
	note = {Number: 1
Publisher: Multidisciplinary Digital Publishing Institute},
	keywords = {C/C++, {ESP}32, microcontroller, {MicroPython}, performance evaluation, Rust, {TinyGo}},
	file = {Full Text PDF:/home/jon/Zotero/storage/SDRQNE3L/Plauska et al. - 2023 - Performance Evaluation of CC++, MicroPython, Rust.pdf:application/pdf},
}

@inproceedings{ionescu_investigating_2020,
	title = {Investigating the performance of {MicroPython} and C on {ESP}32 and {STM}32 microcontrollers},
	url = {https://ieeexplore.ieee.org/abstract/document/9292199},
	doi = {10.1109/SIITME50350.2020.9292199},
	abstract = {Python is a programming language that is used both by entry level programmers and advanced researchers. {MicroPython} is a software implementation of Python that runs on microcontrollers. This paper will investigate the {MicroPython} execution performance compared to similar C native code on low cost microcontrollers: {STM}32 and {ESP}32. The comparison will target: memory allocation speed; {SHA}-256 and {CRC}-32 performance and will present conclusions regarding the encountered problems and ways to improve the application performance.},
	eventtitle = {2020 {IEEE} 26th International Symposium for Design and Technology in Electronic Packaging ({SIITME})},
	pages = {234--237},
	booktitle = {2020 {IEEE} 26th International Symposium for Design and Technology in Electronic Packaging ({SIITME})},
	author = {Ionescu, Valeriu Manuel and Enescu, Florentina Magda},
	urldate = {2025-01-19},
	date = {2020-10},
	note = {{ISSN}: 2642-7036},
	keywords = {{CRC}, {ESP}32, Hardware, hash, Libraries, Microcontrollers, {MicroPython}, performance, Performance evaluation, Python, Resource management, Software, {STM}32},
	file = {IEEE Xplore Abstract Record:/home/jon/Zotero/storage/Y69KNDWU/9292199.html:text/html},
}

@inproceedings{dokic_micropython_2020,
	location = {Cham},
	title = {{MicroPython} or Arduino C for {ESP}32 - Efficiency for Neural Network Edge Devices},
	isbn = {978-3-030-43364-2},
	doi = {10.1007/978-3-030-43364-2_4},
	abstract = {In the last few years, microcontrollers used for {IoT} devices became more and more powerful, and many authors have started to use them in machine learning systems. Most of the authors used them just for data collecting for {ML} algorithms in the clouds, but some of them implemented {ML} algorithms on the microcontrollers. The goal of this paper is to analyses the neural networks data propagation speed of one popular {SoC} (Espressif System company {ESP}32) with simple neural networks implementation with two different development environment, Arduino {IDE} and {MycroPython}. Neural networks with one hidden layer are used with a different number of neurons. This {SoC} is analysed because some companies started to produce them with {UXGA} (Ultra Extended Graphics Array) camera implemented and it can be used to distribute computing load from central {ML} servers.},
	pages = {33--43},
	booktitle = {Intelligent Computing Systems},
	publisher = {Springer International Publishing},
	author = {Dokic, Kristian and Radisic, Bojan and Cobovic, Mirko},
	editor = {Brito-Loeza, Carlos and Espinosa-Romero, Arturo and Martin-Gonzalez, Anabel and Safi, Asad},
	date = {2020},
	langid = {english},
}
